{
  "version": 3,
  "sources": ["../../convex/src/react/use_paginated_query.ts", "../../convex/src/react/use_queries.ts", "../../convex/src/react/client.ts", "../../convex/src/react/queries_observer.ts", "../../convex/src/react/use_subscription.ts", "../../convex/src/react/auth_helpers.tsx", "../../convex/src/react/ConvexAuthState.tsx", "../../convex/src/react/hydration.tsx"],
  "sourcesContent": ["import { useMemo, useState } from \"react\";\n\nimport { OptimisticLocalStore } from \"../browser/index.js\";\nimport {\n  FunctionReturnType,\n  PaginationOptions,\n  paginationOptsValidator,\n  PaginationResult,\n} from \"../server/index.js\";\nimport { convexToJson, Infer, Value } from \"../values/index.js\";\nimport { useQueries } from \"./use_queries.js\";\nimport {\n  FunctionArgs,\n  FunctionReference,\n  getFunctionName,\n} from \"../server/api.js\";\nimport { BetterOmit, Expand } from \"../type_utils.js\";\n\n/**\n * A {@link server.FunctionReference} that is usable with {@link usePaginatedQuery}.\n *\n * This function reference must:\n * - Refer to a public query\n * - Have an argument named \"paginationOpts\" of type {@link server.PaginationOptions}\n * - Have a return type of {@link server.PaginationResult}.\n *\n * @public\n */\nexport type PaginatedQueryReference = FunctionReference<\n  \"query\",\n  \"public\",\n  { paginationOpts: PaginationOptions },\n  PaginationResult<any>\n>;\n\n// Incrementing integer for each page queried in the usePaginatedQuery hook.\ntype QueryPageKey = number;\n\ntype UsePaginatedQueryState = {\n  query: FunctionReference<\"query\">;\n  args: Record<string, Value>;\n  id: number;\n  nextPageKey: QueryPageKey;\n  pageKeys: QueryPageKey[];\n  queries: Record<\n    QueryPageKey,\n    {\n      query: FunctionReference<\"query\">;\n      // Use the validator type as a test that it matches the args\n      // we generate.\n      args: { paginationOpts: Infer<typeof paginationOptsValidator> };\n    }\n  >;\n  ongoingSplits: Record<QueryPageKey, [QueryPageKey, QueryPageKey]>;\n  skip: boolean;\n};\n\nconst splitQuery =\n  (key: QueryPageKey, splitCursor: string, continueCursor: string) =>\n  (prevState: UsePaginatedQueryState) => {\n    const queries = { ...prevState.queries };\n    const splitKey1 = prevState.nextPageKey;\n    const splitKey2 = prevState.nextPageKey + 1;\n    const nextPageKey = prevState.nextPageKey + 2;\n    queries[splitKey1] = {\n      query: prevState.query,\n      args: {\n        ...prevState.args,\n        paginationOpts: {\n          ...prevState.queries[key].args.paginationOpts,\n          endCursor: splitCursor,\n        },\n      },\n    };\n    queries[splitKey2] = {\n      query: prevState.query,\n      args: {\n        ...prevState.args,\n        paginationOpts: {\n          ...prevState.queries[key].args.paginationOpts,\n          cursor: splitCursor,\n          endCursor: continueCursor,\n        },\n      },\n    };\n    const ongoingSplits = { ...prevState.ongoingSplits };\n    ongoingSplits[key] = [splitKey1, splitKey2];\n    return {\n      ...prevState,\n      nextPageKey,\n      queries,\n      ongoingSplits,\n    };\n  };\n\nconst completeSplitQuery =\n  (key: QueryPageKey) => (prevState: UsePaginatedQueryState) => {\n    const completedSplit = prevState.ongoingSplits[key];\n    if (completedSplit === undefined) {\n      return prevState;\n    }\n    const queries = { ...prevState.queries };\n    delete queries[key];\n    const ongoingSplits = { ...prevState.ongoingSplits };\n    delete ongoingSplits[key];\n    let pageKeys = prevState.pageKeys.slice();\n    const pageIndex = prevState.pageKeys.findIndex((v) => v === key);\n    if (pageIndex >= 0) {\n      pageKeys = [\n        ...prevState.pageKeys.slice(0, pageIndex),\n        ...completedSplit,\n        ...prevState.pageKeys.slice(pageIndex + 1),\n      ];\n    }\n    return {\n      ...prevState,\n      queries,\n      pageKeys,\n      ongoingSplits,\n    };\n  };\n\n/**\n * Load data reactively from a paginated query to a create a growing list.\n *\n * This can be used to power \"infinite scroll\" UIs.\n *\n * This hook must be used with public query references that match\n * {@link PaginatedQueryReference}.\n *\n * `usePaginatedQuery` concatenates all the pages of results into a single list\n * and manages the continuation cursors when requesting more items.\n *\n * Example usage:\n * ```typescript\n * const { results, status, isLoading, loadMore } = usePaginatedQuery(\n *   api.messages.list,\n *   { channel: \"#general\" },\n *   { initialNumItems: 5 }\n * );\n * ```\n *\n * If the query reference or arguments change, the pagination state will be reset\n * to the first page. Similarly, if any of the pages result in an InvalidCursor\n * error or an error associated with too much data, the pagination state will also\n * reset to the first page.\n *\n * To learn more about pagination, see [Paginated Queries](https://docs.convex.dev/database/pagination).\n *\n * @param query - A FunctionReference to the public query function to run.\n * @param args - The arguments object for the query function, excluding\n * the `paginationOpts` property. That property is injected by this hook.\n * @param options - An object specifying the `initialNumItems` to be loaded in\n * the first page.\n * @returns A {@link UsePaginatedQueryResult} that includes the currently loaded\n * items, the status of the pagination, and a `loadMore` function.\n *\n * @public\n */\nexport function usePaginatedQuery<Query extends PaginatedQueryReference>(\n  query: Query,\n  args: PaginatedQueryArgs<Query> | \"skip\",\n  options: { initialNumItems: number },\n): UsePaginatedQueryReturnType<Query> {\n  if (\n    typeof options?.initialNumItems !== \"number\" ||\n    options.initialNumItems < 0\n  ) {\n    throw new Error(\n      `\\`options.initialNumItems\\` must be a positive number. Received \\`${options?.initialNumItems}\\`.`,\n    );\n  }\n  const skip = args === \"skip\";\n  const argsObject = skip ? {} : args;\n  const queryName = getFunctionName(query);\n  const createInitialState = useMemo(() => {\n    return () => {\n      const id = nextPaginationId();\n      return {\n        query,\n        args: argsObject as Record<string, Value>,\n        id,\n        nextPageKey: 1,\n        pageKeys: skip ? [] : [0],\n        queries: skip\n          ? ({} as UsePaginatedQueryState[\"queries\"])\n          : {\n              0: {\n                query,\n                args: {\n                  ...argsObject,\n                  paginationOpts: {\n                    numItems: options.initialNumItems,\n                    cursor: null,\n                    id,\n                  },\n                },\n              },\n            },\n        ongoingSplits: {},\n        skip,\n      };\n    };\n    // ESLint doesn't like that we're stringifying the args. We do this because\n    // we want to avoid rerendering if the args are a different\n    // object that serializes to the same result.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    JSON.stringify(convexToJson(argsObject as Value)),\n    queryName,\n    options.initialNumItems,\n    skip,\n  ]);\n\n  const [state, setState] =\n    useState<UsePaginatedQueryState>(createInitialState);\n\n  // `currState` is the state that we'll render based on.\n  let currState = state;\n  if (\n    getFunctionName(query) !== getFunctionName(state.query) ||\n    JSON.stringify(convexToJson(argsObject as Value)) !==\n      JSON.stringify(convexToJson(state.args)) ||\n    skip !== state.skip\n  ) {\n    currState = createInitialState();\n    setState(currState);\n  }\n\n  const resultsObject = useQueries(currState.queries);\n\n  const [results, maybeLastResult]: [\n    Value[],\n    undefined | PaginationResult<Value>,\n  ] = useMemo(() => {\n    let currResult = undefined;\n\n    const allItems = [];\n    for (const pageKey of currState.pageKeys) {\n      currResult = resultsObject[pageKey];\n      if (currResult === undefined) {\n        break;\n      }\n\n      if (currResult instanceof Error) {\n        if (currResult.message.includes(\"InvalidCursor\")) {\n          // - InvalidCursor: If the cursor is invalid, probably the paginated\n          // database query was data-dependent and changed underneath us. The\n          // cursor in the params or journal no longer matches the current\n          // database query.\n\n          // In all cases, we want to restart pagination to throw away all our\n          // existing cursors.\n          console.warn(\n            \"usePaginatedQuery hit error, resetting pagination state: \" +\n              currResult.message,\n          );\n          setState(createInitialState);\n          return [[], undefined];\n        } else {\n          throw currResult;\n        }\n      }\n      const ongoingSplit = currState.ongoingSplits[pageKey];\n      if (ongoingSplit !== undefined) {\n        if (\n          resultsObject[ongoingSplit[0]] !== undefined &&\n          resultsObject[ongoingSplit[1]] !== undefined\n        ) {\n          // Both pages of the split have results now. Swap them in.\n          setState(completeSplitQuery(pageKey));\n        }\n      } else if (\n        currResult.splitCursor &&\n        (currResult.pageStatus === \"SplitRecommended\" ||\n          currResult.pageStatus === \"SplitRequired\" ||\n          currResult.page.length > options.initialNumItems * 2)\n      ) {\n        // If a single page has more than double the expected number of items,\n        // or if the server requests a split, split the page into two.\n        setState(\n          splitQuery(\n            pageKey,\n            currResult.splitCursor,\n            currResult.continueCursor,\n          ),\n        );\n      }\n      if (currResult.pageStatus === \"SplitRequired\") {\n        // If pageStatus is 'SplitRequired', it means the server was not able to\n        // fetch the full page. So we stop results before the incomplete\n        // page and return 'LoadingMore' while the page is splitting.\n        return [allItems, undefined];\n      }\n      allItems.push(...currResult.page);\n    }\n    return [allItems, currResult];\n  }, [\n    resultsObject,\n    currState.pageKeys,\n    currState.ongoingSplits,\n    options.initialNumItems,\n    createInitialState,\n  ]);\n\n  const statusObject = useMemo(() => {\n    if (maybeLastResult === undefined) {\n      if (currState.nextPageKey === 1) {\n        return {\n          status: \"LoadingFirstPage\",\n          isLoading: true,\n          loadMore: (_numItems: number) => {\n            // Intentional noop.\n          },\n        } as const;\n      } else {\n        return {\n          status: \"LoadingMore\",\n          isLoading: true,\n          loadMore: (_numItems: number) => {\n            // Intentional noop.\n          },\n        } as const;\n      }\n    }\n    if (maybeLastResult.isDone) {\n      return {\n        status: \"Exhausted\",\n        isLoading: false,\n        loadMore: (_numItems: number) => {\n          // Intentional noop.\n        },\n      } as const;\n    }\n    const continueCursor = maybeLastResult.continueCursor;\n    let alreadyLoadingMore = false;\n    return {\n      status: \"CanLoadMore\",\n      isLoading: false,\n      loadMore: (numItems: number) => {\n        if (!alreadyLoadingMore) {\n          alreadyLoadingMore = true;\n          setState((prevState) => {\n            const pageKeys = [...prevState.pageKeys, prevState.nextPageKey];\n            const queries = { ...prevState.queries };\n            queries[prevState.nextPageKey] = {\n              query: prevState.query,\n              args: {\n                ...prevState.args,\n                paginationOpts: {\n                  numItems,\n                  cursor: continueCursor,\n                  id: prevState.id,\n                },\n              },\n            };\n            return {\n              ...prevState,\n              nextPageKey: prevState.nextPageKey + 1,\n              pageKeys,\n              queries,\n            };\n          });\n        }\n      },\n    } as const;\n  }, [maybeLastResult, currState.nextPageKey]);\n\n  return {\n    results,\n    ...statusObject,\n  };\n}\n\nlet paginationId = 0;\n/**\n * Generate a new, unique ID for a pagination session.\n *\n * Every usage of {@link usePaginatedQuery} puts a unique ID into the\n * query function arguments as a \"cache-buster\". This serves two purposes:\n *\n * 1. All calls to {@link usePaginatedQuery} have independent query\n * journals.\n *\n * Every time we start a new pagination session, we'll load the first page of\n * results and receive a fresh journal. Without the ID, we might instead reuse\n * a query subscription already present in our client. This isn't desirable\n * because the existing query function result may have grown or shrunk from the\n * requested `initialNumItems`.\n *\n * 2. We can restart the pagination session on some types of errors.\n *\n * Sometimes we want to restart pagination from the beginning if we hit an error.\n * Similar to (1), we'd like to ensure that this new session actually requests\n * its first page from the server and doesn't reuse a query result already\n * present in the client that may have hit the error.\n *\n * @returns The pagination ID.\n */\nfunction nextPaginationId(): number {\n  paginationId++;\n  return paginationId;\n}\n\n/**\n * Reset pagination id for tests only, so tests know what it is.\n */\nexport function resetPaginationId() {\n  paginationId = 0;\n}\n\n/**\n * The result of calling the {@link usePaginatedQuery} hook.\n *\n * This includes:\n * - `results` - An array of the currently loaded results.\n * - `isLoading` - Whether the hook is currently loading results.\n * - `status` - The status of the pagination. The possible statuses are:\n *   - \"LoadingFirstPage\": The hook is loading the first page of results.\n *   - \"CanLoadMore\": This query may have more items to fetch. Call `loadMore` to\n *   fetch another page.\n *   - \"LoadingMore\": We're currently loading another page of results.\n *   - \"Exhausted\": We've paginated to the end of the list.\n * - `loadMore(n)` A callback to fetch more results. This will only fetch more\n * results if the status is \"CanLoadMore\".\n *\n * @public\n */\nexport type UsePaginatedQueryResult<Item> = {\n  results: Item[];\n  loadMore: (numItems: number) => void;\n} & (\n  | {\n      status: \"LoadingFirstPage\";\n      isLoading: true;\n    }\n  | {\n      status: \"CanLoadMore\";\n      isLoading: false;\n    }\n  | {\n      status: \"LoadingMore\";\n      isLoading: true;\n    }\n  | {\n      status: \"Exhausted\";\n      isLoading: false;\n    }\n);\n\n/**\n * The possible pagination statuses in {@link UsePaginatedQueryResult}.\n *\n * This is a union of string literal types.\n * @public\n */\nexport type PaginationStatus = UsePaginatedQueryResult<any>[\"status\"];\n\n/**\n * Given a {@link PaginatedQueryReference}, get the type of the arguments\n * object for the query, excluding the `paginationOpts` argument.\n *\n * @public\n */\nexport type PaginatedQueryArgs<Query extends PaginatedQueryReference> = Expand<\n  BetterOmit<FunctionArgs<Query>, \"paginationOpts\">\n>;\n\n/**\n * Given a {@link PaginatedQueryReference}, get the type of the item being\n * paginated over.\n * @public\n */\nexport type PaginatedQueryItem<Query extends PaginatedQueryReference> =\n  FunctionReturnType<Query>[\"page\"][number];\n\n/**\n * The return type of {@link usePaginatedQuery}.\n *\n * @public\n */\nexport type UsePaginatedQueryReturnType<Query extends PaginatedQueryReference> =\n  UsePaginatedQueryResult<PaginatedQueryItem<Query>>;\n\n/**\n * Optimistically update the values in a paginated list.\n *\n * This optimistic update is designed to be used to update data loaded with\n * {@link usePaginatedQuery}. It updates the list by applying\n * `updateValue` to each element of the list across all of the loaded pages.\n *\n * This will only apply to queries with a matching names and arguments.\n *\n * Example usage:\n * ```ts\n * const myMutation = useMutation(api.myModule.myMutation)\n * .withOptimisticUpdate((localStore, mutationArg) => {\n *\n *   // Optimistically update the document with ID `mutationArg`\n *   // to have an additional property.\n *\n *   optimisticallyUpdateValueInPaginatedQuery(\n *     localStore,\n *     api.myModule.paginatedQuery\n *     {},\n *     currentValue => {\n *       if (mutationArg === currentValue._id) {\n *         return {\n *           ...currentValue,\n *           \"newProperty\": \"newValue\",\n *         };\n *       }\n *       return currentValue;\n *     }\n *   );\n *\n * });\n * ```\n *\n * @param localStore - An {@link OptimisticLocalStore} to update.\n * @param query - A {@link FunctionReference} for the paginated query to update.\n * @param args - The arguments object to the query function, excluding the\n * `paginationOpts` property.\n * @param updateValue - A function to produce the new values.\n *\n * @public\n */\nexport function optimisticallyUpdateValueInPaginatedQuery<\n  Query extends PaginatedQueryReference,\n>(\n  localStore: OptimisticLocalStore,\n  query: Query,\n  args: PaginatedQueryArgs<Query>,\n  updateValue: (\n    currentValue: PaginatedQueryItem<Query>,\n  ) => PaginatedQueryItem<Query>,\n): void {\n  const expectedArgs = JSON.stringify(convexToJson(args as Value));\n\n  for (const queryResult of localStore.getAllQueries(query)) {\n    if (queryResult.value !== undefined) {\n      const { paginationOpts: _, ...innerArgs } = queryResult.args as {\n        paginationOpts: PaginationOptions;\n      };\n      if (JSON.stringify(convexToJson(innerArgs as Value)) === expectedArgs) {\n        const value = queryResult.value;\n        if (\n          typeof value === \"object\" &&\n          value !== null &&\n          Array.isArray(value.page)\n        ) {\n          localStore.setQuery(query, queryResult.args, {\n            ...value,\n            page: value.page.map(updateValue),\n          });\n        }\n      }\n    }\n  }\n}\n", "import { Value } from \"../values/index.js\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { useConvex } from \"./client.js\";\nimport { CreateWatch, QueriesObserver } from \"./queries_observer.js\";\nimport { useSubscription } from \"./use_subscription.js\";\nimport { QueryJournal } from \"../browser/index.js\";\nimport { FunctionReference } from \"../server/api.js\";\n\n/**\n * Load a variable number of reactive Convex queries.\n *\n * `useQueries` is similar to {@link useQuery} but it allows\n * loading multiple queries which can be useful for loading a dynamic number\n * of queries without violating the rules of React hooks.\n *\n * This hook accepts an object whose keys are identifiers for each query and the\n * values are objects of `{ query: FunctionReference, args: Record<string, Value> }`. The\n * `query` is a FunctionReference for the Convex query function to load, and the `args` are\n * the arguments to that function.\n *\n * The hook returns an object that maps each identifier to the result of the query,\n * `undefined` if the query is still loading, or an instance of `Error` if the query\n * threw an exception.\n *\n * For example if you loaded a query like:\n * ```typescript\n * const results = useQueries({\n *   messagesInGeneral: {\n *     query: \"listMessages\",\n *     args: { channel: \"#general\" }\n *   }\n * });\n * ```\n * then the result would look like:\n * ```typescript\n * {\n *   messagesInGeneral: [{\n *     channel: \"#general\",\n *     body: \"hello\"\n *     _id: ...,\n *     _creationTime: ...\n *   }]\n * }\n * ```\n *\n * This React hook contains internal state that will cause a rerender\n * whenever any of the query results change.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * @param queries - An object mapping identifiers to objects of\n * `{query: string, args: Record<string, Value> }` describing which query\n * functions to fetch.\n * @returns An object with the same keys as the input. The values are the result\n * of the query function, `undefined` if it's still loading, or an `Error` if\n * it threw an exception.\n *\n * @public\n */\nexport function useQueries(\n  queries: RequestForQueries,\n): Record<string, any | undefined | Error> {\n  const convex = useConvex();\n  if (convex === undefined) {\n    // Error message includes `useQuery` because this hook is called by `useQuery`\n    // more often than it's called directly.\n    throw new Error(\n      \"Could not find Convex client! `useQuery` must be used in the React component \" +\n        \"tree under `ConvexProvider`. Did you forget it? \" +\n        \"See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\",\n    );\n  }\n  const createWatch = useMemo(() => {\n    return (\n      query: FunctionReference<\"query\">,\n      args: Record<string, Value>,\n      journal?: QueryJournal,\n    ) => {\n      return convex.watchQuery(query, args, { journal });\n    };\n  }, [convex]);\n  return useQueriesHelper(queries, createWatch);\n}\n\n/**\n * Internal version of `useQueries` that is exported for testing.\n */\nexport function useQueriesHelper(\n  queries: RequestForQueries,\n  createWatch: CreateWatch,\n): Record<string, any | undefined | Error> {\n  const [observer] = useState(() => new QueriesObserver(createWatch));\n\n  if (observer.createWatch !== createWatch) {\n    observer.setCreateWatch(createWatch);\n  }\n\n  // Unsubscribe from all queries on unmount.\n  useEffect(() => () => observer.destroy(), [observer]);\n\n  const subscription = useMemo(\n    () => ({\n      getCurrentValue: () => {\n        return observer.getLocalResults(queries);\n      },\n      subscribe: (callback: () => void) => {\n        observer.setQueries(queries);\n        return observer.subscribe(callback);\n      },\n    }),\n    [observer, queries],\n  );\n\n  return useSubscription(subscription);\n}\n\n/**\n * An object representing a request to load multiple queries.\n *\n * The keys of this object are identifiers and the values are objects containing\n * the query function and the arguments to pass to it.\n *\n * This is used as an argument to {@link useQueries}.\n * @public\n */\nexport type RequestForQueries = Record<\n  string,\n  {\n    query: FunctionReference<\"query\">;\n    args: Record<string, Value>;\n  }\n>;\n", "import { BaseConvexClient } from \"../browser/index.js\";\nimport type { OptimisticUpdate, QueryToken } from \"../browser/index.js\";\nimport React, { useContext, useMemo } from \"react\";\nimport { convexToJson, Value } from \"../values/index.js\";\nimport ReactDOM from \"react-dom\";\nimport { QueryJournal } from \"../browser/sync/protocol.js\";\nimport {\n  AuthTokenFetcher,\n  BaseConvexClientOptions,\n  ConnectionState,\n} from \"../browser/sync/client.js\";\nimport type { UserIdentityAttributes } from \"../browser/sync/protocol.js\";\nimport { RequestForQueries, useQueries } from \"./use_queries.js\";\nimport { parseArgs } from \"../common/index.js\";\nimport {\n  ArgsAndOptions,\n  FunctionArgs,\n  FunctionReference,\n  FunctionReturnType,\n  OptionalRestArgs,\n  getFunctionName,\n  makeFunctionReference,\n} from \"../server/api.js\";\nimport { EmptyObject } from \"../server/registration.js\";\n\nif (typeof React === \"undefined\") {\n  throw new Error(\"Required dependency 'react' not found\");\n}\nif (typeof ReactDOM === \"undefined\") {\n  throw new Error(\"Required dependency 'react-dom' not found\");\n}\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex mutation function on the server.\n *\n * @public\n */\nexport interface ReactMutation<Mutation extends FunctionReference<\"mutation\">> {\n  /**\n   * Execute the mutation on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the mutation to pass up to the server.\n   * @returns The return value of the server-side function call.\n   */\n  (...args: OptionalRestArgs<Mutation>): Promise<FunctionReturnType<Mutation>>;\n\n  /**\n   * Define an optimistic update to apply as part of this mutation.\n   *\n   * This is a temporary update to the local query results to facilitate a\n   * fast, interactive UI. It enables query results to update before a mutation\n   * executed on the server.\n   *\n   * When the mutation is invoked, the optimistic update will be applied.\n   *\n   * Optimistic updates can also be used to temporarily remove queries from the\n   * client and create loading experiences until a mutation completes and the\n   * new query results are synced.\n   *\n   * The update will be automatically rolled back when the mutation is fully\n   * completed and queries have been updated.\n   *\n   * @param optimisticUpdate - The optimistic update to apply.\n   * @returns A new `ReactMutation` with the update configured.\n   *\n   * @public\n   */\n  withOptimisticUpdate(\n    optimisticUpdate: OptimisticUpdate<FunctionArgs<Mutation>>,\n  ): ReactMutation<Mutation>;\n}\n\n// Exported only for testing.\nexport function createMutation(\n  mutationReference: FunctionReference<\"mutation\">,\n  client: ConvexReactClient,\n  update?: OptimisticUpdate<any>,\n): ReactMutation<any> {\n  function mutation(args?: Record<string, Value>): Promise<unknown> {\n    assertNotAccidentalArgument(args);\n\n    return client.mutation(mutationReference, args, {\n      optimisticUpdate: update,\n    });\n  }\n  mutation.withOptimisticUpdate = function withOptimisticUpdate(\n    optimisticUpdate: OptimisticUpdate<any>,\n  ): ReactMutation<any> {\n    if (update !== undefined) {\n      throw new Error(\n        `Already specified optimistic update for mutation ${getFunctionName(\n          mutationReference,\n        )}`,\n      );\n    }\n    return createMutation(mutationReference, client, optimisticUpdate);\n  };\n  return mutation as ReactMutation<any>;\n}\n\n/**\n * An interface to execute a Convex action on the server.\n *\n * @public\n */\nexport interface ReactAction<Action extends FunctionReference<\"action\">> {\n  /**\n   * Execute the function on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the function to pass up to the server.\n   * @returns The return value of the server-side function call.\n   * @public\n   */\n  (...args: OptionalRestArgs<Action>): Promise<FunctionReturnType<Action>>;\n}\n\nfunction createAction(\n  actionReference: FunctionReference<\"action\">,\n  client: ConvexReactClient,\n): ReactAction<any> {\n  return function (args?: Record<string, Value>): Promise<unknown> {\n    return client.action(actionReference, args);\n  } as ReactAction<any>;\n}\n\n/**\n * A watch on the output of a Convex query function.\n *\n * @public\n */\nexport interface Watch<T> {\n  /**\n   * Initiate a watch on the output of a query.\n   *\n   * This will subscribe to this query and call\n   * the callback whenever the query result changes.\n   *\n   * **Important: If the client is already subscribed to this query with the\n   * same arguments this callback will not be invoked until the query result is\n   * updated.** To get the current, local result call\n   * {@link react.Watch.localQueryResult}.\n   *\n   * @param callback - Function that is called whenever the query result changes.\n   * @returns - A function that disposes of the subscription.\n   */\n  onUpdate(callback: () => void): () => void;\n\n  /**\n   * Get the current result of a query.\n   *\n   * This will only return a result if we're already subscribed to the query\n   * and have received a result from the server or the query value has been set\n   * optimistically.\n   *\n   * @returns The result of the query or `undefined` if it isn't known.\n   * @throws An error if the query encountered an error on the server.\n   */\n  localQueryResult(): T | undefined;\n\n  /**\n   * @internal\n   */\n  localQueryLogs(): string[] | undefined;\n\n  /**\n   * Get the current {@link browser.QueryJournal} for this query.\n   *\n   * If we have not yet received a result for this query, this will be `undefined`.\n   */\n  journal(): QueryJournal | undefined;\n}\n\n/**\n * Options for {@link ConvexReactClient.watchQuery}.\n *\n * @public\n */\nexport interface WatchQueryOptions {\n  /**\n   * An (optional) journal produced from a previous execution of this query\n   * function.\n   *\n   * If there is an existing subscription to a query function with the same\n   * name and arguments, this journal will have no effect.\n   */\n  journal?: QueryJournal;\n}\n\n/**\n * Options for {@link ConvexReactClient.mutation}.\n *\n * @public\n */\nexport interface MutationOptions<Args extends Record<string, Value>> {\n  /**\n   * An optimistic update to apply along with this mutation.\n   *\n   * An optimistic update locally updates queries while a mutation is pending.\n   * Once the mutation completes, the update will be rolled back.\n   */\n  optimisticUpdate?: OptimisticUpdate<Args>;\n}\n\n/**\n * Options for {@link ConvexReactClient}.\n *\n * @public\n */\nexport interface ConvexReactClientOptions extends BaseConvexClientOptions {}\n\n/**\n * A Convex client for use within React.\n *\n * This loads reactive queries and executes mutations over a WebSocket.\n *\n * @public\n */\nexport class ConvexReactClient {\n  private address: string;\n  private cachedSync?: BaseConvexClient;\n  private listeners: Map<QueryToken, Set<() => void>>;\n  private options: ConvexReactClientOptions;\n  private closed = false;\n\n  private adminAuth?: string;\n  private fakeUserIdentity?: UserIdentityAttributes;\n\n  /**\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param options - See {@link ConvexReactClientOptions} for a full description.\n   */\n  constructor(address: string, options?: ConvexReactClientOptions) {\n    // Validate address immediately since validation by the lazily-instantiated\n    // internal client does not occur synchronously.\n    if (typeof address !== \"string\") {\n      throw new Error(\n        \"ConvexReactClient requires a URL like 'https://happy-otter-123.convex.cloud'.\",\n      );\n    }\n    if (!address.includes(\"://\")) {\n      throw new Error(\"Provided address was not an absolute URL.\");\n    }\n    this.address = address;\n    this.listeners = new Map();\n    this.options = { ...options };\n  }\n\n  /**\n   * Lazily instantiate the `BaseConvexClient` so we don't create the WebSocket\n   * when server-side rendering.\n   *\n   * @internal\n   */\n  get sync() {\n    if (this.closed) {\n      throw new Error(\"ConvexReactClient has already been closed.\");\n    }\n    if (this.cachedSync) {\n      return this.cachedSync;\n    }\n    this.cachedSync = new BaseConvexClient(\n      this.address,\n      (updatedQueries) => this.transition(updatedQueries),\n      this.options,\n    );\n    if (this.adminAuth) {\n      this.cachedSync.setAdminAuth(this.adminAuth, this.fakeUserIdentity);\n    }\n    return this.cachedSync;\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token\n   * @param onChange - a callback that will be called when the authentication status changes\n   */\n  setAuth(\n    fetchToken: AuthTokenFetcher,\n    onChange?: (isAuthenticated: boolean) => void,\n  ) {\n    if (typeof fetchToken === \"string\") {\n      throw new Error(\n        \"Passing a string to ConvexReactClient.setAuth is no longer supported, \" +\n          \"please upgrade to passing in an async function to handle reauthentication.\",\n      );\n    }\n    this.sync.setAuth(\n      fetchToken,\n      onChange ??\n        (() => {\n          // Do nothing\n        }),\n    );\n  }\n\n  /**\n   * Clear the current authentication token if set.\n   */\n  clearAuth() {\n    this.sync.clearAuth();\n  }\n\n  /**\n   * @internal\n   */\n  setAdminAuth(token: string, identity?: UserIdentityAttributes) {\n    this.adminAuth = token;\n    this.fakeUserIdentity = identity;\n    if (this.closed) {\n      throw new Error(\"ConvexReactClient has already been closed.\");\n    }\n    if (this.cachedSync) {\n      this.sync.setAdminAuth(token, identity);\n    }\n  }\n\n  /**\n   * Construct a new {@link Watch} on a Convex query function.\n   *\n   * **Most application code should not call this method directly. Instead use\n   * the {@link useQuery} hook.**\n   *\n   * @param query - A {@link server.FunctionReference} for the public query to run.\n   * @param args - An arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @param options - A {@link WatchQueryOptions} options object for this query.\n   *\n   * @returns The {@link Watch} object.\n   */\n  watchQuery<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    ...argsAndOptions: ArgsAndOptions<Query, WatchQueryOptions>\n  ): Watch<FunctionReturnType<Query>> {\n    const [args, options] = argsAndOptions;\n    const name = getFunctionName(query);\n    return {\n      onUpdate: (callback) => {\n        const { queryToken, unsubscribe } = this.sync.subscribe(\n          name as string,\n          args,\n          options,\n        );\n\n        const currentListeners = this.listeners.get(queryToken);\n        if (currentListeners !== undefined) {\n          currentListeners.add(callback);\n        } else {\n          this.listeners.set(queryToken, new Set([callback]));\n        }\n\n        return () => {\n          if (this.closed) {\n            return;\n          }\n\n          const currentListeners = this.listeners.get(queryToken)!;\n          currentListeners.delete(callback);\n          if (currentListeners.size === 0) {\n            this.listeners.delete(queryToken);\n          }\n          unsubscribe();\n        };\n      },\n\n      localQueryResult: () => {\n        // Use the cached client because we can't have a query result if we don't\n        // even have a client yet!\n        if (this.cachedSync) {\n          return this.cachedSync.localQueryResult(name, args);\n        }\n        return undefined;\n      },\n\n      localQueryLogs: () => {\n        if (this.cachedSync) {\n          return this.cachedSync.localQueryLogs(name, args);\n        }\n        return undefined;\n      },\n\n      journal: () => {\n        if (this.cachedSync) {\n          return this.cachedSync.queryJournal(name, args);\n        }\n        return undefined;\n      },\n    };\n  }\n\n  /**\n   * Execute a mutation function.\n   *\n   * @param mutation - A {@link server.FunctionReference} for the public mutation\n   * to run.\n   * @param args - An arguments object for the mutation. If this is omitted,\n   * the arguments will be `{}`.\n   * @param options - A {@link MutationOptions} options object for the mutation.\n   * @returns A promise of the mutation's result.\n   */\n  mutation<Mutation extends FunctionReference<\"mutation\">>(\n    mutation: Mutation,\n    ...argsAndOptions: ArgsAndOptions<\n      Mutation,\n      MutationOptions<FunctionArgs<Mutation>>\n    >\n  ): Promise<FunctionReturnType<Mutation>> {\n    const [args, options] = argsAndOptions;\n    const name = getFunctionName(mutation);\n    return this.sync.mutation(name, args, options);\n  }\n\n  /**\n   * Execute an action function.\n   *\n   * @param action - A {@link server.FunctionReference} for the public action\n   * to run.\n   * @param args - An arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */\n  action<Action extends FunctionReference<\"action\">>(\n    action: Action,\n    ...args: OptionalRestArgs<Action>\n  ): Promise<FunctionReturnType<Action>> {\n    const name = getFunctionName(action);\n    return this.sync.action(name, ...args);\n  }\n\n  /**\n   * Fetch a query result once.\n   *\n   * **Most application code should subscribe to queries instead, using\n   * the {@link useQuery} hook.**\n   *\n   * @param query - A {@link server.FunctionReference} for the public query\n   * to run.\n   * @param args - An arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   */\n  query<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    ...args: OptionalRestArgs<Query>\n  ): Promise<FunctionReturnType<Query>> {\n    const watch = this.watchQuery(query, ...args);\n    const existingResult = watch.localQueryResult();\n    if (existingResult !== undefined) {\n      return existingResult;\n    }\n    return new Promise((resolve, reject) => {\n      const unsubscribe = watch.onUpdate(() => {\n        unsubscribe();\n        try {\n          resolve(watch.localQueryResult());\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n\n  /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */\n  connectionState(): ConnectionState {\n    return this.sync.connectionState();\n  }\n\n  /**\n   * Close any network handles associated with this client and stop all subscriptions.\n   *\n   * Call this method when you're done with a {@link ConvexReactClient} to\n   * dispose of its sockets and resources.\n   *\n   * @returns A `Promise` fulfilled when the connection has been completely closed.\n   */\n  async close(): Promise<void> {\n    this.closed = true;\n    // Prevent outstanding React batched updates from invoking listeners.\n    this.listeners = new Map();\n    if (this.cachedSync) {\n      const sync = this.cachedSync;\n      this.cachedSync = undefined;\n      await sync.close();\n    }\n  }\n\n  private transition(updatedQueries: QueryToken[]) {\n    ReactDOM.unstable_batchedUpdates(() => {\n      for (const queryToken of updatedQueries) {\n        const callbacks = this.listeners.get(queryToken);\n        if (callbacks) {\n          for (const callback of callbacks) {\n            callback();\n          }\n        }\n      }\n    });\n  }\n}\n\nconst ConvexContext = React.createContext<ConvexReactClient>(\n  undefined as unknown as ConvexReactClient, // in the future this will be a mocked client for testing\n);\n\n/**\n * Get the {@link ConvexReactClient} within a React component.\n *\n * This relies on the {@link ConvexProvider} being above in the React component tree.\n *\n * @returns The active {@link ConvexReactClient} object, or `undefined`.\n *\n * @public\n */\nexport function useConvex(): ConvexReactClient {\n  return useContext(ConvexContext);\n}\n\n/**\n * Provides an active Convex {@link ConvexReactClient} to descendants of this component.\n *\n * Wrap your app in this component to use Convex hooks `useQuery`,\n * `useMutation`, and `useConvex`.\n *\n * @param props - an object with a `client` property that refers to a {@link ConvexReactClient}.\n *\n * @public\n */\nexport const ConvexProvider: React.FC<{\n  client: ConvexReactClient;\n  children?: React.ReactNode;\n}> = ({ client, children }) => {\n  return React.createElement(\n    ConvexContext.Provider,\n    { value: client },\n    children,\n  );\n};\n\nexport type OptionalRestArgsOrSkip<FuncRef extends FunctionReference<any>> =\n  FuncRef[\"_args\"] extends EmptyObject\n    ? [args?: EmptyObject | \"skip\"]\n    : [args: FuncRef[\"_args\"] | \"skip\"];\n\n/**\n * Load a reactive query within a React component.\n *\n * This React hook contains internal state that will cause a rerender\n * whenever the query result changes.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * @param query - a {@link server.FunctionReference} for the public query to run\n * like `api.dir1.dir2.filename.func`.\n * @param args - The arguments to the query function or the string \"skip\" if the\n * query should not be loaded.\n * @returns the result of the query. If the query is loading returns `undefined`.\n *\n * @public\n */\nexport function useQuery<Query extends FunctionReference<\"query\">>(\n  query: Query,\n  ...args: OptionalRestArgsOrSkip<Query>\n): Query[\"_returnType\"] | undefined {\n  const skip = args[0] === \"skip\";\n  const argsObject = args[0] === \"skip\" ? {} : parseArgs(args[0]);\n\n  const queryReference =\n    typeof query === \"string\"\n      ? makeFunctionReference<\"query\", any, any>(query)\n      : query;\n\n  const queryName = getFunctionName(queryReference);\n\n  const queries = useMemo(\n    () =>\n      skip\n        ? ({} as RequestForQueries)\n        : { query: { query: queryReference, args: argsObject } },\n    // Stringify args so args that are semantically the same don't trigger a\n    // rerender. Saves developers from adding `useMemo` on every args usage.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [JSON.stringify(convexToJson(argsObject)), queryName, skip],\n  );\n\n  const results = useQueries(queries);\n  const result = results[\"query\"];\n  if (result instanceof Error) {\n    throw result;\n  }\n  return result;\n}\n\n/**\n * Construct a new {@link ReactMutation}.\n *\n * Mutation objects can be called like functions to request execution of the\n * corresponding Convex function, or further configured with\n * [optimistic updates](https://docs.convex.dev/using/optimistic-updates).\n *\n * The value returned by this hook is stable across renders, so it can be used\n * by React dependency arrays and memoization logic relying on object identity\n * without causing rerenders.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * @param mutation - A {@link server.FunctionReference} for the public mutation\n * to run like `api.dir1.dir2.filename.func`.\n * @returns The {@link ReactMutation} object with that name.\n *\n * @public\n */\nexport function useMutation<Mutation extends FunctionReference<\"mutation\">>(\n  mutation: Mutation,\n): ReactMutation<Mutation> {\n  const mutationReference =\n    typeof mutation === \"string\"\n      ? makeFunctionReference<\"mutation\", any, any>(mutation)\n      : mutation;\n\n  const convex = useContext(ConvexContext);\n  if (convex === undefined) {\n    throw new Error(\n      \"Could not find Convex client! `useMutation` must be used in the React component \" +\n        \"tree under `ConvexProvider`. Did you forget it? \" +\n        \"See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\",\n    );\n  }\n  return useMemo(\n    () => createMutation(mutationReference, convex),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [convex, getFunctionName(mutationReference)],\n  );\n}\n\n/**\n * Construct a new {@link ReactAction}.\n *\n * Action objects can be called like functions to request execution of the\n * corresponding Convex function.\n *\n * The value returned by this hook is stable across renders, so it can be used\n * by React dependency arrays and memoization logic relying on object identity\n * without causing rerenders.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * @param action - A {@link server.FunctionReference} for the public action\n * to run like `api.dir1.dir2.filename.func`.\n * @returns The {@link ReactAction} object with that name.\n *\n * @public\n */\nexport function useAction<Action extends FunctionReference<\"action\">>(\n  action: Action,\n): ReactAction<Action> {\n  const convex = useContext(ConvexContext);\n  const actionReference =\n    typeof action === \"string\"\n      ? makeFunctionReference<\"action\", any, any>(action)\n      : action;\n\n  if (convex === undefined) {\n    throw new Error(\n      \"Could not find Convex client! `useAction` must be used in the React component \" +\n        \"tree under `ConvexProvider`. Did you forget it? \" +\n        \"See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\",\n    );\n  }\n  return useMemo(\n    () => createAction(actionReference, convex),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [convex, getFunctionName(actionReference)],\n  );\n}\n\n// When a function is called with a single argument that looks like a\n// React SyntheticEvent it was likely called as an event handler.\nfunction assertNotAccidentalArgument(value: any) {\n  // these are properties of a React.SyntheticEvent\n  // https://reactjs.org/docs/events.html\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"bubbles\" in value &&\n    \"persist\" in value &&\n    \"isDefaultPrevented\" in value\n  ) {\n    throw new Error(\n      `Convex function called with SyntheticEvent object. Did you use a Convex function as an event handler directly? Event handlers like onClick receive an event object as their first argument. These SyntheticEvent objects are not valid Convex values. Try wrapping the function like \\`const handler = () => myMutation();\\` and using \\`handler\\` in the event handler.`,\n    );\n  }\n}\n", "import { convexToJson, Value } from \"../values/index.js\";\nimport { Watch } from \"./client.js\";\nimport { QueryJournal } from \"../browser/sync/protocol.js\";\nimport { FunctionReference, getFunctionName } from \"../server/api.js\";\n\ntype Identifier = string;\n\ntype QueryInfo = {\n  query: FunctionReference<\"query\">;\n  args: Record<string, Value>;\n  watch: Watch<Value>;\n  unsubscribe: () => void;\n};\n\nexport type CreateWatch = (\n  query: FunctionReference<\"query\">,\n  args: Record<string, Value>,\n  journal?: QueryJournal,\n) => Watch<Value>;\n\n/**\n * A class for observing the results of multiple queries at the same time.\n *\n * Any time the result of a query changes, the listeners are notified.\n */\nexport class QueriesObserver {\n  public createWatch: CreateWatch;\n  private queries: Record<Identifier, QueryInfo>;\n  private listeners: Set<() => void>;\n\n  constructor(createWatch: CreateWatch) {\n    this.createWatch = createWatch;\n    this.queries = {};\n    this.listeners = new Set();\n  }\n\n  setQueries(\n    newQueries: Record<\n      Identifier,\n      { query: FunctionReference<\"query\">; args: Record<string, Value> }\n    >,\n  ) {\n    // Add the new queries before unsubscribing from the old ones so that\n    // the deduping in the `ConvexReactClient` can help if there are duplicates.\n    for (const identifier of Object.keys(newQueries)) {\n      const { query, args } = newQueries[identifier];\n      // Might throw\n      getFunctionName(query);\n\n      if (this.queries[identifier] === undefined) {\n        // No existing query => add it.\n        this.addQuery(identifier, query, args);\n      } else {\n        const existingInfo = this.queries[identifier];\n        if (\n          getFunctionName(query) !== getFunctionName(existingInfo.query) ||\n          JSON.stringify(convexToJson(args)) !==\n            JSON.stringify(convexToJson(existingInfo.args))\n        ) {\n          // Existing query that doesn't match => remove the old and add the new.\n          this.removeQuery(identifier);\n          this.addQuery(identifier, query, args);\n        }\n      }\n    }\n\n    // Prune all the existing queries that we no longer need.\n    for (const identifier of Object.keys(this.queries)) {\n      if (newQueries[identifier] === undefined) {\n        this.removeQuery(identifier);\n      }\n    }\n  }\n\n  subscribe(listener: () => void): () => void {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  getLocalResults(\n    queries: Record<\n      Identifier,\n      { query: FunctionReference<\"query\">; args: Record<string, Value> }\n    >,\n  ): Record<Identifier, Value | undefined | Error> {\n    const result: Record<Identifier, Value | Error | undefined> = {};\n    for (const identifier of Object.keys(queries)) {\n      const { query, args } = queries[identifier];\n      // Might throw\n      getFunctionName(query);\n\n      // Note: We're not gonna watch, we could save some allocations\n      // by getting a reference to the client directly instead.\n      const watch = this.createWatch(query, args);\n      let value: Value | undefined | Error;\n      try {\n        value = watch.localQueryResult();\n      } catch (e) {\n        // Only collect instances of `Error` because thats how callers\n        // will distinguish errors from normal results.\n        if (e instanceof Error) {\n          value = e;\n        } else {\n          throw e;\n        }\n      }\n      result[identifier] = value;\n    }\n    return result;\n  }\n\n  setCreateWatch(createWatch: CreateWatch) {\n    this.createWatch = createWatch;\n    // If we have a new watch, we might be using a new Convex client.\n    // Recreate all the watches being careful to preserve the journals.\n    for (const identifier of Object.keys(this.queries)) {\n      const { query, args, watch } = this.queries[identifier];\n      const journal = watch.journal();\n      this.removeQuery(identifier);\n      this.addQuery(identifier, query, args, journal);\n    }\n  }\n\n  destroy() {\n    for (const identifier of Object.keys(this.queries)) {\n      this.removeQuery(identifier);\n    }\n    this.listeners = new Set();\n  }\n\n  private addQuery(\n    identifier: Identifier,\n    query: FunctionReference<\"query\">,\n    args: Record<string, Value>,\n    journal?: QueryJournal,\n  ) {\n    if (this.queries[identifier] !== undefined) {\n      throw new Error(\n        `Tried to add a new query with identifier ${identifier} when it already exists.`,\n      );\n    }\n    const watch = this.createWatch(query, args, journal);\n    const unsubscribe = watch.onUpdate(() => this.notifyListeners());\n    this.queries[identifier] = {\n      query,\n      args,\n      watch,\n      unsubscribe,\n    };\n  }\n\n  private removeQuery(identifier: Identifier) {\n    const info = this.queries[identifier];\n    if (info === undefined) {\n      throw new Error(`No query found with identifier ${identifier}.`);\n    }\n    info.unsubscribe();\n    delete this.queries[identifier];\n  }\n\n  private notifyListeners(): void {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n}\n", "import { useEffect, useState } from \"react\";\n\n/*\nThis code is taken from https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\nbecause correct subscriptions in async React is complex!\n\nIt could probably be replaced with `useSyncExternalStore()`.\n\nThe MIT License (MIT)\nCopyright \u00A9 2023 Brian Vaughn\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \u201CSoftware\u201D), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \u201CAS IS\u201D, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n/**\n * Hook used for safely managing subscriptions in concurrent mode.\n *\n * In order to avoid removing and re-adding subscriptions each time this hook is called,\n * the parameters passed to this hook should be memoized in some way\u2013\n * either by wrapping the entire params object with useMemo()\n * or by wrapping the individual callbacks with useCallback().\n *\n * @internal\n */\nexport function useSubscription<Value>({\n  // (Synchronously) returns the current value of our subscription.\n  getCurrentValue,\n\n  // This function is passed an event handler to attach to the subscription.\n  // It should return an unsubscribe function that removes the handler.\n  subscribe,\n}: {\n  getCurrentValue: () => Value;\n  subscribe: (callback: () => void) => () => void;\n}): Value {\n  // Read the current value from our subscription.\n  // When this value changes, we'll schedule an update with React.\n  // It's important to also store the hook params so that we can check for staleness.\n  // (See the comment in checkForUpdates() below for more info.)\n  const [state, setState] = useState(() => ({\n    getCurrentValue,\n    subscribe,\n    value: getCurrentValue(),\n  }));\n\n  let valueToReturn = state.value;\n\n  // If parameters have changed since our last render, schedule an update with its current value.\n  if (\n    state.getCurrentValue !== getCurrentValue ||\n    state.subscribe !== subscribe\n  ) {\n    // If the subscription has been updated, we'll schedule another update with React.\n    // React will process this update immediately, so the old subscription value won't be committed.\n    // It is still nice to avoid returning a mismatched value though, so let's override the return value.\n    valueToReturn = getCurrentValue();\n\n    setState({\n      getCurrentValue,\n      subscribe,\n      value: valueToReturn,\n    });\n  }\n\n  // It is important not to subscribe while rendering because this can lead to memory leaks.\n  // (Learn more at reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects)\n  // Instead, we wait until the commit phase to attach our handler.\n  //\n  // We intentionally use a passive effect (useEffect) rather than a synchronous one (useLayoutEffect)\n  // so that we don't stretch the commit phase.\n  // This also has an added benefit when multiple components are subscribed to the same source:\n  // It allows each of the event handlers to safely schedule work without potentially removing an another handler.\n  // (Learn more at https://codesandbox.io/s/k0yvr5970o)\n  useEffect(() => {\n    let didUnsubscribe = false;\n\n    const checkForUpdates = () => {\n      // It's possible that this callback will be invoked even after being unsubscribed,\n      // if it's removed as a result of a subscription event/update.\n      // In this case, React will log a DEV warning about an update from an unmounted component.\n      // We can avoid triggering that warning with this check.\n      if (didUnsubscribe) {\n        return;\n      }\n\n      setState((prevState) => {\n        // Ignore values from stale sources!\n        // Since we subscribe an unsubscribe in a passive effect,\n        // it's possible that this callback will be invoked for a stale (previous) subscription.\n        // This check avoids scheduling an update for that stale subscription.\n        if (\n          prevState.getCurrentValue !== getCurrentValue ||\n          prevState.subscribe !== subscribe\n        ) {\n          return prevState;\n        }\n\n        // Some subscriptions will auto-invoke the handler, even if the value hasn't changed.\n        // If the value hasn't changed, no update is needed.\n        // Return state as-is so React can bail out and avoid an unnecessary render.\n        const value = getCurrentValue();\n        if (prevState.value === value) {\n          return prevState;\n        }\n\n        return { ...prevState, value };\n      });\n    };\n    const unsubscribe = subscribe(checkForUpdates);\n\n    // Because we're subscribing in a passive effect,\n    // it's possible that an update has occurred between render and our effect handler.\n    // Check for this and schedule an update if work has occurred.\n    checkForUpdates();\n\n    return () => {\n      didUnsubscribe = true;\n      unsubscribe();\n    };\n  }, [getCurrentValue, subscribe]);\n\n  // Return the current value for our caller to use while rendering.\n  return valueToReturn;\n}\n", "import React from \"react\";\nimport { ReactNode } from \"react\";\nimport { useConvexAuth } from \"./ConvexAuthState.js\";\n\n/**\n * Renders children if the client is authenticated.\n *\n * @public\n */\nexport function Authenticated({ children }: { children: ReactNode }) {\n  const { isLoading, isAuthenticated } = useConvexAuth();\n  if (isLoading || !isAuthenticated) {\n    return null;\n  }\n  return <>{children}</>;\n}\n\n/**\n * Renders children if the client is using authentication but is not authenticated.\n *\n * @public\n */\nexport function Unauthenticated({ children }: { children: ReactNode }) {\n  const { isLoading, isAuthenticated } = useConvexAuth();\n  if (isLoading || isAuthenticated) {\n    return null;\n  }\n  return <>{children}</>;\n}\n\n/**\n * Renders children if the client isn't using authentication or is in the process\n * of authenticating.\n *\n * @public\n */\nexport function AuthLoading({ children }: { children: ReactNode }) {\n  const { isLoading } = useConvexAuth();\n  if (!isLoading) {\n    return null;\n  }\n  return <>{children}</>;\n}\n", "import React, {\n  createContext,\n  ReactNode,\n  useContext,\n  useEffect,\n  useState,\n} from \"react\";\nimport { AuthTokenFetcher } from \"../browser/sync/client.js\";\nimport { ConvexProvider } from \"./client.js\";\n\n// Until we can import from our own entry points (requires TypeScript 4.7),\n// just describe the interface enough to help users pass the right type.\ntype IConvexReactClient = {\n  setAuth(\n    fetchToken: AuthTokenFetcher,\n    onChange: (isAuthenticated: boolean) => void,\n  ): void;\n  clearAuth(): void;\n};\n\n/**\n * Type representing the state of an auth integration with Convex.\n *\n * @public\n */\nexport type ConvexAuthState = {\n  isLoading: boolean;\n  isAuthenticated: boolean;\n};\n\nconst ConvexAuthContext = createContext<ConvexAuthState>(undefined as any);\n\n/**\n * Get the {@link ConvexAuthState} within a React component.\n *\n * This relies on a Convex auth integration provider being above in the React\n * component tree.\n *\n * @returns The current {@link ConvexAuthState}.\n *\n * @public\n */\nexport function useConvexAuth(): {\n  isLoading: boolean;\n  isAuthenticated: boolean;\n} {\n  const authContext = useContext(ConvexAuthContext);\n  if (authContext === undefined) {\n    throw new Error(\n      \"Could not find `ConvexProviderWithAuth` (or `ConvexProviderWithClerk` \" +\n        \"or `ConvexProviderWithAuth0`) \" +\n        \"as an ancestor component. This component may be missing, or you \" +\n        \"might have two instances of the `convex/react` module loaded in your \" +\n        \"project.\",\n    );\n  }\n  return authContext;\n}\n\n/**\n * A replacement for {@link ConvexProvider} which additionally provides\n * {@link ConvexAuthState} to descendants of this component.\n *\n * Use this to integrate any auth provider with Convex. The `useAuth` prop\n * should be a React hook that returns the provider's authentication state\n * and a function to fetch a JWT access token.\n *\n * See [Custom Auth Integration](https://docs.convex.dev/auth/advanced/custom-auth) for more information.\n *\n * @public\n */\nexport function ConvexProviderWithAuth({\n  children,\n  client,\n  useAuth,\n}: {\n  children?: ReactNode;\n  client: IConvexReactClient;\n  useAuth: () => {\n    isLoading: boolean;\n    isAuthenticated: boolean;\n    fetchAccessToken: (args: {\n      forceRefreshToken: boolean;\n    }) => Promise<string | null>;\n  };\n}) {\n  const { isLoading, isAuthenticated, fetchAccessToken } = useAuth();\n  const [isConvexAuthenticated, setIsConvexAuthenticated] = useState<\n    boolean | null\n  >(null);\n\n  useEffect(() => {\n    let isThisEffectRelevant = true;\n\n    async function setToken() {\n      client.setAuth(fetchAccessToken, (isAuthenticated) => {\n        if (isThisEffectRelevant) {\n          setIsConvexAuthenticated(isAuthenticated);\n        }\n      });\n    }\n\n    if (isAuthenticated) {\n      void setToken();\n      return () => {\n        isThisEffectRelevant = false;\n\n        // If we haven't finished fetching the token by now\n        // we shouldn't transition to a loaded state\n        setIsConvexAuthenticated((isConvexAuthenticated) =>\n          isConvexAuthenticated ? false : null,\n        );\n        client.clearAuth();\n      };\n    }\n  }, [isAuthenticated, fetchAccessToken, isLoading, client]);\n\n  // If the useAuth went back to the loading state (which is unusual but possible)\n  // reset the Convex auth state to null so that we can correctly\n  // transition the state from \"loading\" to \"authenticated\"\n  // without going through \"unauthenticated\".\n  if (isLoading && isConvexAuthenticated !== null) {\n    setIsConvexAuthenticated(null);\n  }\n\n  if (!isLoading && !isAuthenticated && isConvexAuthenticated !== false) {\n    setIsConvexAuthenticated(false);\n  }\n\n  return (\n    <ConvexAuthContext.Provider\n      value={{\n        isLoading: isConvexAuthenticated === null,\n        isAuthenticated: isAuthenticated && (isConvexAuthenticated ?? false),\n      }}\n    >\n      <ConvexProvider client={client as any}>{children}</ConvexProvider>\n    </ConvexAuthContext.Provider>\n  );\n}\n", "import { useMemo } from \"react\";\nimport { useQuery } from \"../react/client.js\";\nimport { FunctionReference, makeFunctionReference } from \"../server/api.js\";\nimport { jsonToConvex } from \"../values/index.js\";\n\n/**\n * The preloaded query payload, which should be passed to a client component\n * and passed to {@link usePreloadedQuery}.\n *\n * @public\n */\nexport type Preloaded<Query extends FunctionReference<\"query\">> = {\n  __type: Query;\n  _name: string;\n  _argsJSON: string;\n  _valueJSON: string;\n};\n\n/**\n * Load a reactive query within a React component using a `Preloaded` payload\n * from a Server Component returned by {@link nextjs.preloadQuery}.\n *\n * This React hook contains internal state that will cause a rerender\n * whenever the query result changes.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * @param preloadedQuery - The `Preloaded` query payload from a Server Component.\n * @returns the result of the query. Initially returns the result fetched\n * by the Server Component. Subsequently returns the result fetched by the client.\n *\n * @public\n */\nexport function usePreloadedQuery<Query extends FunctionReference<\"query\">>(\n  preloadedQuery: Preloaded<Query>,\n): Query[\"_returnType\"] {\n  const args = useMemo(\n    () => jsonToConvex(preloadedQuery._argsJSON),\n    [preloadedQuery._argsJSON],\n  ) as Query[\"_args\"];\n  const preloadedResult = useMemo(\n    () => jsonToConvex(preloadedQuery._valueJSON),\n    [preloadedQuery._valueJSON],\n  );\n  const result = useQuery(\n    makeFunctionReference(preloadedQuery._name) as Query,\n    args,\n  );\n  return result === undefined ? preloadedResult : result;\n}\n"],
  "mappings": "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",
  "names": ["import_react", "import_react", "React", "ReactDOM", "currentListeners", "import_react", "import_react", "import_react", "isAuthenticated", "isConvexAuthenticated", "React", "React", "import_react"]
}

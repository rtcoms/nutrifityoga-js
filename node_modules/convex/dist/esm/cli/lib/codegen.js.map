{
  "version": 3,
  "sources": ["../../../../src/cli/lib/codegen.ts"],
  "sourcesContent": ["import path from \"path\";\nimport prettier from \"prettier\";\nimport { withTmpDir, TempDir } from \"../../bundler/fs.js\";\nimport { entryPoints } from \"../../bundler/index.js\";\nimport { apiCodegen } from \"../codegen_templates/api.js\";\nimport { apiCjsCodegen } from \"../codegen_templates/api_cjs.js\";\nimport {\n  dataModel,\n  dataModelWithoutSchema,\n} from \"../codegen_templates/dataModel.js\";\nimport { readmeCodegen } from \"../codegen_templates/readme.js\";\nimport { serverCodegen } from \"../codegen_templates/server.js\";\nimport { tsconfigCodegen } from \"../codegen_templates/tsconfig.js\";\nimport {\n  Context,\n  logError,\n  logMessage,\n  logOutput,\n} from \"../../bundler/context.js\";\nimport { typeCheckFunctionsInMode, TypeCheckMode } from \"./typecheck.js\";\nimport { readProjectConfig } from \"./config.js\";\nimport { recursivelyDelete } from \"./fsUtils.js\";\nimport {\n  componentServerDTS,\n  componentServerJS,\n  componentServerStubDTS,\n} from \"../codegen_templates/component_server.js\";\nimport { ComponentDirectory } from \"./components/definition/directoryStructure.js\";\nimport { StartPushResponse } from \"./deployApi/startPush.js\";\n\nexport async function doInitCodegen(\n  ctx: Context,\n  functionsDir: string,\n  skipIfExists: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n): Promise<void> {\n  await withTmpDir(async (tmpDir) => {\n    await doReadmeCodegen(ctx, tmpDir, functionsDir, skipIfExists, opts);\n    await doTsconfigCodegen(ctx, tmpDir, functionsDir, skipIfExists, opts);\n  });\n}\n\nexport async function doCodegen(\n  ctx: Context,\n  functionsDir: string,\n  typeCheckMode: TypeCheckMode,\n  opts?: { dryRun?: boolean; generateCommonJSApi?: boolean; debug?: boolean },\n) {\n  const { projectConfig } = await readProjectConfig(ctx);\n  // Delete the old _generated.ts because v0.1.2 used to put the react generated\n  // code there\n  const legacyCodegenPath = path.join(functionsDir, \"_generated.ts\");\n  if (ctx.fs.exists(legacyCodegenPath)) {\n    if (opts?.dryRun) {\n      logError(\n        ctx,\n        `Command would delete legacy codegen file: ${legacyCodegenPath}}`,\n      );\n    } else {\n      logError(ctx, `Deleting legacy codegen file: ${legacyCodegenPath}}`);\n      ctx.fs.unlink(legacyCodegenPath);\n    }\n  }\n\n  // Create the codegen dir if it doesn't already exist.\n  const codegenDir = path.join(functionsDir, \"_generated\");\n  ctx.fs.mkdir(codegenDir, { allowExisting: true, recursive: true });\n\n  await withTmpDir(async (tmpDir) => {\n    // Write files in dependency order so a watching dev server doesn't\n    // see inconsistent results where a file we write imports from a\n    // file that doesn't exist yet. We'll collect all the paths we write\n    // and then delete any remaining paths at the end.\n    const writtenFiles = [];\n\n    // First, `dataModel.d.ts` imports from the developer's `schema.js` file.\n    const schemaFiles = await doDataModelCodegen(\n      ctx,\n      tmpDir,\n      functionsDir,\n      codegenDir,\n      opts,\n    );\n    writtenFiles.push(...schemaFiles);\n\n    // Next, the `server.d.ts` file imports from `dataModel.d.ts`.\n    const serverFiles = await doServerCodegen(ctx, tmpDir, codegenDir, opts);\n    writtenFiles.push(...serverFiles);\n\n    // The `api.d.ts` file imports from the developer's modules, which then\n    // import from `server.d.ts`. Note that there's a cycle here, since the\n    // developer's modules could also import from the `api.{js,d.ts}` files.\n    const apiFiles = await doApiCodegen(\n      ctx,\n      tmpDir,\n      functionsDir,\n      codegenDir,\n      opts?.generateCommonJSApi || projectConfig.generateCommonJSApi,\n      opts,\n    );\n    writtenFiles.push(...apiFiles);\n\n    // Cleanup any files that weren't written in this run.\n    for (const file of ctx.fs.listDir(codegenDir)) {\n      if (!writtenFiles.includes(file.name)) {\n        recursivelyDelete(ctx, path.join(codegenDir, file.name), opts);\n      }\n    }\n\n    // Generated code is updated, typecheck the query and mutation functions.\n    await typeCheckFunctionsInMode(ctx, typeCheckMode, functionsDir);\n  });\n}\n\nexport async function doInitialComponentCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  componentDirectory: ComponentDirectory,\n  opts?: { dryRun?: boolean; generateCommonJSApi?: boolean; debug?: boolean },\n) {\n  const { projectConfig } = await readProjectConfig(ctx);\n\n  // Create the codegen dir if it doesn't already exist.\n  const codegenDir = path.join(componentDirectory.path, \"_generated\");\n  ctx.fs.mkdir(codegenDir, { allowExisting: true, recursive: true });\n\n  // Write files in dependency order so a watching dev server doesn't\n  // see inconsistent results where a file we write imports from a\n  // file that doesn't exist yet. We'll collect all the paths we write\n  // and then delete any remaining paths at the end.\n  const writtenFiles = [];\n\n  // First, `dataModel.d.ts` imports from the developer's `schema.js` file.\n  const schemaFiles = await doDataModelCodegen(\n    ctx,\n    tmpDir,\n    componentDirectory.path,\n    codegenDir,\n    opts,\n  );\n  writtenFiles.push(...schemaFiles);\n\n  // Next, the `server.d.ts` file imports from `dataModel.d.ts`.\n  const serverFiles = await doInitialComponentServerCodegen(\n    ctx,\n    componentDirectory.isRoot,\n    tmpDir,\n    codegenDir,\n    opts,\n  );\n  writtenFiles.push(...serverFiles);\n\n  // The `api.d.ts` file imports from the developer's modules, which then\n  // import from `server.d.ts`. Note that there's a cycle here, since the\n  // developer's modules could also import from the `api.{js,d.ts}` files.\n  const apiFiles = await doApiCodegen(\n    ctx,\n    tmpDir,\n    componentDirectory.path,\n    codegenDir,\n    opts?.generateCommonJSApi || projectConfig.generateCommonJSApi,\n    opts,\n  );\n  writtenFiles.push(...apiFiles);\n\n  // Cleanup any files that weren't written in this run.\n  for (const file of ctx.fs.listDir(codegenDir)) {\n    if (!writtenFiles.includes(file.name)) {\n      recursivelyDelete(ctx, path.join(codegenDir, file.name), opts);\n    }\n  }\n}\n\nexport async function doFinalComponentCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  rootComponent: ComponentDirectory,\n  componentDirectory: ComponentDirectory,\n  startPushResponse: StartPushResponse,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const codegenDir = path.join(componentDirectory.path, \"_generated\");\n  ctx.fs.mkdir(codegenDir, { allowExisting: true, recursive: true });\n\n  // Only `server.d.ts` depends on analyze results, where we replace the stub\n  // generated during initial codegen with a more precise type.\n  const serverDTSPath = path.join(codegenDir, \"server.d.ts\");\n  const serverContents = await componentServerDTS(\n    ctx,\n    startPushResponse,\n    rootComponent,\n    componentDirectory,\n  );\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    serverContents,\n    \"typescript\",\n    serverDTSPath,\n    opts,\n  );\n}\n\nasync function doReadmeCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  functionsDir: string,\n  skipIfExists: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const readmePath = path.join(functionsDir, \"README.md\");\n  if (skipIfExists && ctx.fs.exists(readmePath)) {\n    logMessage(ctx, `Not overwriting README.md.`);\n    return;\n  }\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    readmeCodegen(),\n    \"markdown\",\n    readmePath,\n    opts,\n  );\n}\n\nasync function doTsconfigCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  functionsDir: string,\n  skipIfExists: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const tsconfigPath = path.join(functionsDir, \"tsconfig.json\");\n  if (skipIfExists && ctx.fs.exists(tsconfigPath)) {\n    logMessage(ctx, `Not overwriting tsconfig.json.`);\n    return;\n  }\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    tsconfigCodegen(),\n    \"json\",\n    tsconfigPath,\n    opts,\n  );\n}\n\nasync function doDataModelCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  functionsDir: string,\n  codegenDir: string,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const schemaPath = path.join(functionsDir, \"schema.ts\");\n  const hasSchemaFile = ctx.fs.exists(schemaPath);\n  const schemaContent = hasSchemaFile ? dataModel : dataModelWithoutSchema;\n\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    schemaContent.DTS,\n    \"typescript\",\n    path.join(codegenDir, \"dataModel.d.ts\"),\n    opts,\n  );\n  return [\"dataModel.d.ts\"];\n}\n\nasync function doServerCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  codegenDir: string,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const serverContent = serverCodegen();\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    serverContent.JS,\n    \"typescript\",\n    path.join(codegenDir, \"server.js\"),\n    opts,\n  );\n\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    serverContent.DTS,\n    \"typescript\",\n    path.join(codegenDir, \"server.d.ts\"),\n    opts,\n  );\n\n  return [\"server.js\", \"server.d.ts\"];\n}\n\nasync function doInitialComponentServerCodegen(\n  ctx: Context,\n  isRoot: boolean,\n  tmpDir: TempDir,\n  codegenDir: string,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    componentServerJS(isRoot),\n    \"typescript\",\n    path.join(codegenDir, \"server.js\"),\n    opts,\n  );\n\n  // Don't write our stub if the file already exists: It probably\n  // has better type information than this stub.\n  const serverDTSPath = path.join(codegenDir, \"server.d.ts\");\n  if (!ctx.fs.exists(serverDTSPath)) {\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      componentServerStubDTS(isRoot),\n      \"typescript\",\n      path.join(codegenDir, \"server.d.ts\"),\n      opts,\n    );\n  }\n\n  return [\"server.js\", \"server.d.ts\"];\n}\n\nasync function doApiCodegen(\n  ctx: Context,\n  tmpDir: TempDir,\n  functionsDir: string,\n  codegenDir: string,\n  generateCommonJSApi: boolean,\n  opts?: { dryRun?: boolean; debug?: boolean },\n) {\n  const absModulePaths = await entryPoints(ctx, functionsDir, false);\n  const modulePaths = absModulePaths.map((p) => path.relative(functionsDir, p));\n\n  const apiContent = apiCodegen(modulePaths);\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    apiContent.JS,\n    \"typescript\",\n    path.join(codegenDir, \"api.js\"),\n    opts,\n  );\n  await writeFormattedFile(\n    ctx,\n    tmpDir,\n    apiContent.DTS,\n    \"typescript\",\n    path.join(codegenDir, \"api.d.ts\"),\n    opts,\n  );\n  const writtenFiles = [\"api.js\", \"api.d.ts\"];\n\n  if (generateCommonJSApi) {\n    const apiCjsContent = apiCjsCodegen(modulePaths);\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      apiCjsContent.JS,\n      \"typescript\",\n      path.join(codegenDir, \"api_cjs.cjs\"),\n      opts,\n    );\n    await writeFormattedFile(\n      ctx,\n      tmpDir,\n      apiCjsContent.DTS,\n      \"typescript\",\n      path.join(codegenDir, \"api_cjs.d.cts\"),\n      opts,\n    );\n    writtenFiles.push(\"api_cjs.cjs\", \"api_cjs.d.cts\");\n  }\n\n  return writtenFiles;\n}\n\nasync function writeFormattedFile(\n  ctx: Context,\n  tmpDir: TempDir,\n  contents: string,\n  filetype: string,\n  destination: string,\n  options?: {\n    dryRun?: boolean;\n    debug?: boolean;\n  },\n) {\n  // Run prettier so we don't have to think about formatting!\n  //\n  // This is a little sketchy because we are using the default prettier config\n  // (not our user's one) but it's better than nothing.\n  const formattedContents = await prettier.format(contents, {\n    parser: filetype,\n    pluginSearchDirs: false,\n  });\n  if (options?.debug) {\n    // NB: The `test_codegen_projects_are_up_to_date` smoke test depends\n    // on this output format.\n    logOutput(ctx, `# ${path.basename(destination)}`);\n    logOutput(ctx, formattedContents);\n    return;\n  }\n  try {\n    const existing = ctx.fs.readUtf8File(destination);\n    if (existing === formattedContents) {\n      return;\n    }\n  } catch (err: any) {\n    if (err.code !== \"ENOENT\") {\n      // eslint-disable-next-line no-restricted-syntax\n      throw err;\n    }\n  }\n  if (options?.dryRun) {\n    logOutput(ctx, `Command would write file: ${destination}`);\n    return;\n  }\n  const tmpPath = tmpDir.writeUtf8File(formattedContents);\n  ctx.fs.swapTmpFile(tmpPath, destination);\n}\n"],
  "mappings": ";AAAA,OAAO,UAAU;AACjB,OAAO,cAAc;AACrB,SAAS,kBAA2B;AACpC,SAAS,mBAAmB;AAC5B,SAAS,kBAAkB;AAC3B,SAAS,qBAAqB;AAC9B;AAAA,EACE;AAAA,EACA;AAAA,OACK;AACP,SAAS,qBAAqB;AAC9B,SAAS,qBAAqB;AAC9B,SAAS,uBAAuB;AAChC;AAAA,EAEE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,gCAA+C;AACxD,SAAS,yBAAyB;AAClC,SAAS,yBAAyB;AAClC;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAIP,sBAAsB,cACpB,KACA,cACA,cACA,MACe;AACf,QAAM,WAAW,OAAO,WAAW;AACjC,UAAM,gBAAgB,KAAK,QAAQ,cAAc,cAAc,IAAI;AACnE,UAAM,kBAAkB,KAAK,QAAQ,cAAc,cAAc,IAAI;AAAA,EACvE,CAAC;AACH;AAEA,sBAAsB,UACpB,KACA,cACA,eACA,MACA;AACA,QAAM,EAAE,cAAc,IAAI,MAAM,kBAAkB,GAAG;AAGrD,QAAM,oBAAoB,KAAK,KAAK,cAAc,eAAe;AACjE,MAAI,IAAI,GAAG,OAAO,iBAAiB,GAAG;AACpC,QAAI,MAAM,QAAQ;AAChB;AAAA,QACE;AAAA,QACA,6CAA6C;AAAA,MAC/C;AAAA,IACF,OAAO;AACL,eAAS,KAAK,iCAAiC,oBAAoB;AACnE,UAAI,GAAG,OAAO,iBAAiB;AAAA,IACjC;AAAA,EACF;AAGA,QAAM,aAAa,KAAK,KAAK,cAAc,YAAY;AACvD,MAAI,GAAG,MAAM,YAAY,EAAE,eAAe,MAAM,WAAW,KAAK,CAAC;AAEjE,QAAM,WAAW,OAAO,WAAW;AAKjC,UAAM,eAAe,CAAC;AAGtB,UAAM,cAAc,MAAM;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,iBAAa,KAAK,GAAG,WAAW;AAGhC,UAAM,cAAc,MAAM,gBAAgB,KAAK,QAAQ,YAAY,IAAI;AACvE,iBAAa,KAAK,GAAG,WAAW;AAKhC,UAAM,WAAW,MAAM;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,MAAM,uBAAuB,cAAc;AAAA,MAC3C;AAAA,IACF;AACA,iBAAa,KAAK,GAAG,QAAQ;AAG7B,eAAW,QAAQ,IAAI,GAAG,QAAQ,UAAU,GAAG;AAC7C,UAAI,CAAC,aAAa,SAAS,KAAK,IAAI,GAAG;AACrC,0BAAkB,KAAK,KAAK,KAAK,YAAY,KAAK,IAAI,GAAG,IAAI;AAAA,MAC/D;AAAA,IACF;AAGA,UAAM,yBAAyB,KAAK,eAAe,YAAY;AAAA,EACjE,CAAC;AACH;AAEA,sBAAsB,0BACpB,KACA,QACA,oBACA,MACA;AACA,QAAM,EAAE,cAAc,IAAI,MAAM,kBAAkB,GAAG;AAGrD,QAAM,aAAa,KAAK,KAAK,mBAAmB,MAAM,YAAY;AAClE,MAAI,GAAG,MAAM,YAAY,EAAE,eAAe,MAAM,WAAW,KAAK,CAAC;AAMjE,QAAM,eAAe,CAAC;AAGtB,QAAM,cAAc,MAAM;AAAA,IACxB;AAAA,IACA;AAAA,IACA,mBAAmB;AAAA,IACnB;AAAA,IACA;AAAA,EACF;AACA,eAAa,KAAK,GAAG,WAAW;AAGhC,QAAM,cAAc,MAAM;AAAA,IACxB;AAAA,IACA,mBAAmB;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,eAAa,KAAK,GAAG,WAAW;AAKhC,QAAM,WAAW,MAAM;AAAA,IACrB;AAAA,IACA;AAAA,IACA,mBAAmB;AAAA,IACnB;AAAA,IACA,MAAM,uBAAuB,cAAc;AAAA,IAC3C;AAAA,EACF;AACA,eAAa,KAAK,GAAG,QAAQ;AAG7B,aAAW,QAAQ,IAAI,GAAG,QAAQ,UAAU,GAAG;AAC7C,QAAI,CAAC,aAAa,SAAS,KAAK,IAAI,GAAG;AACrC,wBAAkB,KAAK,KAAK,KAAK,YAAY,KAAK,IAAI,GAAG,IAAI;AAAA,IAC/D;AAAA,EACF;AACF;AAEA,sBAAsB,wBACpB,KACA,QACA,eACA,oBACA,mBACA,MACA;AACA,QAAM,aAAa,KAAK,KAAK,mBAAmB,MAAM,YAAY;AAClE,MAAI,GAAG,MAAM,YAAY,EAAE,eAAe,MAAM,WAAW,KAAK,CAAC;AAIjE,QAAM,gBAAgB,KAAK,KAAK,YAAY,aAAa;AACzD,QAAM,iBAAiB,MAAM;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,eAAe,gBACb,KACA,QACA,cACA,cACA,MACA;AACA,QAAM,aAAa,KAAK,KAAK,cAAc,WAAW;AACtD,MAAI,gBAAgB,IAAI,GAAG,OAAO,UAAU,GAAG;AAC7C,eAAW,KAAK,4BAA4B;AAC5C;AAAA,EACF;AACA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,cAAc;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,eAAe,kBACb,KACA,QACA,cACA,cACA,MACA;AACA,QAAM,eAAe,KAAK,KAAK,cAAc,eAAe;AAC5D,MAAI,gBAAgB,IAAI,GAAG,OAAO,YAAY,GAAG;AAC/C,eAAW,KAAK,gCAAgC;AAChD;AAAA,EACF;AACA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,gBAAgB;AAAA,IAChB;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,eAAe,mBACb,KACA,QACA,cACA,YACA,MACA;AACA,QAAM,aAAa,KAAK,KAAK,cAAc,WAAW;AACtD,QAAM,gBAAgB,IAAI,GAAG,OAAO,UAAU;AAC9C,QAAM,gBAAgB,gBAAgB,YAAY;AAElD,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,cAAc;AAAA,IACd;AAAA,IACA,KAAK,KAAK,YAAY,gBAAgB;AAAA,IACtC;AAAA,EACF;AACA,SAAO,CAAC,gBAAgB;AAC1B;AAEA,eAAe,gBACb,KACA,QACA,YACA,MACA;AACA,QAAM,gBAAgB,cAAc;AACpC,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,cAAc;AAAA,IACd;AAAA,IACA,KAAK,KAAK,YAAY,WAAW;AAAA,IACjC;AAAA,EACF;AAEA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,cAAc;AAAA,IACd;AAAA,IACA,KAAK,KAAK,YAAY,aAAa;AAAA,IACnC;AAAA,EACF;AAEA,SAAO,CAAC,aAAa,aAAa;AACpC;AAEA,eAAe,gCACb,KACA,QACA,QACA,YACA,MACA;AACA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,kBAAkB,MAAM;AAAA,IACxB;AAAA,IACA,KAAK,KAAK,YAAY,WAAW;AAAA,IACjC;AAAA,EACF;AAIA,QAAM,gBAAgB,KAAK,KAAK,YAAY,aAAa;AACzD,MAAI,CAAC,IAAI,GAAG,OAAO,aAAa,GAAG;AACjC,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA,uBAAuB,MAAM;AAAA,MAC7B;AAAA,MACA,KAAK,KAAK,YAAY,aAAa;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAEA,SAAO,CAAC,aAAa,aAAa;AACpC;AAEA,eAAe,aACb,KACA,QACA,cACA,YACA,qBACA,MACA;AACA,QAAM,iBAAiB,MAAM,YAAY,KAAK,cAAc,KAAK;AACjE,QAAM,cAAc,eAAe,IAAI,CAAC,MAAM,KAAK,SAAS,cAAc,CAAC,CAAC;AAE5E,QAAM,aAAa,WAAW,WAAW;AACzC,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,WAAW;AAAA,IACX;AAAA,IACA,KAAK,KAAK,YAAY,QAAQ;AAAA,IAC9B;AAAA,EACF;AACA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,WAAW;AAAA,IACX;AAAA,IACA,KAAK,KAAK,YAAY,UAAU;AAAA,IAChC;AAAA,EACF;AACA,QAAM,eAAe,CAAC,UAAU,UAAU;AAE1C,MAAI,qBAAqB;AACvB,UAAM,gBAAgB,cAAc,WAAW;AAC/C,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd;AAAA,MACA,KAAK,KAAK,YAAY,aAAa;AAAA,MACnC;AAAA,IACF;AACA,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd;AAAA,MACA,KAAK,KAAK,YAAY,eAAe;AAAA,MACrC;AAAA,IACF;AACA,iBAAa,KAAK,eAAe,eAAe;AAAA,EAClD;AAEA,SAAO;AACT;AAEA,eAAe,mBACb,KACA,QACA,UACA,UACA,aACA,SAIA;AAKA,QAAM,oBAAoB,MAAM,SAAS,OAAO,UAAU;AAAA,IACxD,QAAQ;AAAA,IACR,kBAAkB;AAAA,EACpB,CAAC;AACD,MAAI,SAAS,OAAO;AAGlB,cAAU,KAAK,KAAK,KAAK,SAAS,WAAW,GAAG;AAChD,cAAU,KAAK,iBAAiB;AAChC;AAAA,EACF;AACA,MAAI;AACF,UAAM,WAAW,IAAI,GAAG,aAAa,WAAW;AAChD,QAAI,aAAa,mBAAmB;AAClC;AAAA,IACF;AAAA,EACF,SAAS,KAAP;AACA,QAAI,IAAI,SAAS,UAAU;AAEzB,YAAM;AAAA,IACR;AAAA,EACF;AACA,MAAI,SAAS,QAAQ;AACnB,cAAU,KAAK,6BAA6B,aAAa;AACzD;AAAA,EACF;AACA,QAAM,UAAU,OAAO,cAAc,iBAAiB;AACtD,MAAI,GAAG,YAAY,SAAS,WAAW;AACzC;",
  "names": []
}
